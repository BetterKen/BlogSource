---
title: SQL开发规范
date: 2020-04-20 23:01:00
tags:
    - 规范
    - Mysql
categories:
    - 基础
    - 规范
---

## 1 基础规范

- 【强制】使用INNODB存储引擎
- 【强制】表字符集使用UTF8mb4
- 【强制】所有表都需要添加注释
- 【建议】单表数据量建议控制在5000W以内
- 【强制】不在数据库中存储图、文件等大数据
- 【强制】 禁止使用外键、触发器、存储过程

## 2 命名规范

- 【强制】库名、表名、字段名必须使用小写字母，“_”分割
- 【强制】库名以"_db"结尾,eg:crm_db;
- 【建议】表名以"t_"开头,eg:t_crm_user_info;
- 【强制】表名由两部分组成:表前缀+表意名
- 【建议】库名、表名、字段名见名知意,建议使用名词而不是动词。
- 【建议】库名、表名、字段名不超过12个字符。
- 【强制】临时库、临时表名必须以tmp为前缀,并以日期为后缀
- 【强制】备份库、表必须以bak为前缀,并以日期为后缀
- 【强制】非唯一索引按照`IX_表简写_字段简写`命名
- 【强制】唯一索引按照`UQ_表简写_字段简写`命名


## 3 库、表、字段开发设计规范

- 【强制】单实例表数目必须小于500
- 【强制】大字段、访问频率低的字段拆分到单独的表中存储,分离冷热数据
- 【强制】单表列数目必须小于30
- 【强制】表必须有主键,且与业务无关，例如自增主键
- 【强制】禁止使用外键,如果有外键完整性约束,需要应用程序控制
- 【强制】字段名采用规范的英文小写格式,并且以下划线"_"分割,长度不能超过3个单词长 度,单个单词长度超过10个字母的应当使用缩写,禁止使用mysql的关键字作为字段名
- 【禁止】在数据库中存储明文密码,把密码加密后存储
- 【建议】字段定义为NOT NULL,需为空字段可定义为NOT NULL DEFAULT ''或0(0不要赋予实际意义)
- 【强制】存储精确浮点数必须使用DECIMAL替代FLOAT和DOUBLE
- 【建议】使用UNSIGNED存储非负数值
- 【建议】整形定义中建议采用INT(10),而不是INT(1),INT(11)或其他
- 【强制】存储状态，性别等，用TINYINT，如果不需要负数加UNSIGNED。使用TINYINT UNSIGNED
- 【强制】尽可能不使用TEXT、BLOB类型
- 【禁止】数据库中使用VARBINARY、BLOB存储图片、文件等
- VARCHAR(N)，N尽可能小
- 存储年使用YEAR类型
- 存储时间（精确到秒）建议使用TIMESTAMP类型

## 4  索引规范

- 索引的数量控制
    - 单张表中索引数量不超过5个
    - 单个索引中的字段数不超过5个
- 主键准则
    - 表必须有主键
    - 不使用更新频繁的列作为主键
    - 尽量不选择字符串列作为主键
    - 不使用UUID MD5 HASH这些作为主键(数值太离散了)
    - 建议选择自增
- 重要的SQL必须被索引，比如：
   - UPDATE、DELETE语句的WHERE条件列
   - ORDER BY、GROUP BY、DISTINCT的字段
- 多表JOIN的字段注意以下：
   - 区分度最大的字段放在前面
   - 优先考虑覆盖索引
   - 避免冗余和重复索引
   - 索引要综合评估数据密度和分布以及考虑查询和更新比例
- 索引禁忌
   - 不在低基数列上建立索引，例如“性别”
   - 不在索引列进行数学运算和函数运算
- 新建的唯一索引必须不能和主键重复
- 引字段的默认值不能为NULL，要改为其他的default或者空。NULL非常影响索引的查询效率
- 反复查看与表相关的SQL，符合最左前缀的特点建立索引。多条字段重复的语句，要修改语句条件字段的顺序，为其建立一条联合索引，减少索引数量
- 能使用唯一索引就要使用唯一索引，提高查询效率


## 5 语句规范

- UPDATE、DELETE语句不使用LIMIT。
- SELECT语句只获取需要的字段,减少select *。
- WHERE条件中必须使用合适的类型，避免MySQL进行隐式类型转化。
- 避免在SQL语句进行数学运算或者函数运算。
- 避免使用存储过程、触发器、函数等，容易将业务逻辑和DB耦合在一起，并且MySQL的存储过程、触发器、函数中存在一定的bug
- 避免使用JOIN。
- 使用合理的SQL语句减少与数据库的交互次数。
- 不使用ORDER BY RAND()，使用其他方法替换。
- WHERE条件中的非等值条件（IN、BETWEEN、<、<=、>、>=）会导致后面的条件使用不了索引。
- SQL语句中IN包含的值不应过多。
- SELECT、INSERT语句必须显式的指明字段名称，不使用SELECT *，不使用INSERT INTO table()。
- 使用SELECT column_1, column_2 FROM table WHERE[]而不是SELECT column_1 FROM table WHERE[]和SELECT column_2 FROM table WHERE []。
- limit分页注意效率。Limit越大，效率越低。可以改写limit，比如例子改写：select id from tlimit 10000, 10;  =>  select id from t where id > 10000 limit10;



## 6 FAQ

- 建议使用UNSIGNED存储非负数值，同样的字节数，存储的数值范围更大。如tinyint 有符号为 -128-127，无符号为0-255。
- 尽可能不使用TEXT、BLOB类型
    - 索引排序问题，只能使用max_sort_length的长度或者手工指定ORDER BY SUBSTRING(column,length)的长度来排序
    - Memory引擘不支持text,blog类型，会在磁盘上生成临时表
    - 可能浪费更多的空间
    - 可能无法使用adaptive hash index
    - 导致使用where没有索引的语句变慢
- 建议字段定义为NOT NULL
    - 如果null字段被索引，需要额外的1字节
    - 使索引，索引统计，值的比较变得更复杂
    - 可用''，0代替
    - 如果是索引字段，一定要定义为not null 例如：NOT NULL default ''
- 禁止在数据库中使用VARBINARY、BLOB存储图片、文件等。采用分布式文件系统更高效
- VARCHAR(N)，N尽可能小，N表示的是字符数不是字节数，比如VARCHAR(255)，可以最大可存储255个汉字，需要根据实际的宽度来选择N。VARCHAR(N)，因为MySQL一个表中所有的VARCHAR字段最大长度是65535个字节21845个汉字，进行排序和创建临时表一类的内存操作时，会使用N的长度申请内存。
- 为什么建议使用TIMESTAMP来存储时间而不是DATETIME？
    - DATETIME和TIMESTAMP都是精确到秒，优先选择TIMESTAMP，因为TIMESTAMP只有4个字节，而DATETIME8个字节。同时TIMESTAMP具有自动赋值以及自动更新的特性。
- 为什么一张表中不能存在过多的索引？
    - InnoDB的secondaryindex使用b+tree来存储，因此在UPDATE、DELETE、INSERT的时候需要对b+tree进行调整，过多的索引会减慢更新的速度。
- 不建议使用%前缀模糊查询，例如LIKE “%weibo”。会导致全表扫描
- UPDATE、DELETE语句不使用LIMIT。
    - 可能导致主从数据不一致
    - 会记录到错误日志，导致日志占用大量空间
- 为什么需要避免MySQL进行隐式类型转化？
    - 因为MySQL进行隐式类型转化之后，可能会将索引字段类型转化成=号右边值的类型，导致使用不到索引。
- 为什么不建议使用SELECT *?
    - 增加很多不必要的消耗（cpu、io、内存、网络带宽）
- 为什么不能使用ORDER BY rand()？
    - 因为ORDER BYrand()会将数据从磁盘中读取，进行排序，会消耗大量的IO和CPU，可以在程序中获取一个rand值，然后通过在从数据库中获取对应的值




